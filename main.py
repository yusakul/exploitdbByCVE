#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# This is a sample Python script.

# Press Shift+F10 to execute it or replace it with your code.
# Press Double Shift to search everywhere for classes, files, tool windows, actions, and settings.
import csv
import json
import os
import sys
import re
import argparse
import json
import datetime
import pygit2
from pathlib import Path
from typing import List, Dict

pdir = os.path.dirname(os.path.abspath(__file__))

cve_map = {}
cve_map_path = {}

def is_repo(edb: Path) -> bool:
    """
    :param edb: path to directory to verify
    :return: is it a valid git repo?
    """
    try:
        pygit2.Repository(edb)
        print(f"[*] Looks like {edb} is a git repo, but make sure it's up to date yourself.")
        return True
    except pygit2.GitError as err:
        print("[!]", err)
        return False


def clone_exploitdb(edb: Path) -> None:
    """
    :param edb: where to clone the repo
    :return: None
    """
    try:
        remote_uri = "https://github.com/offensive-security/exploitdb.git"
        print(f"[*] Trying to clone into {edb}")
        pygit2.clone_repository(remote_uri, edb)
    except ValueError as err:
        print("[!]", err)
        sys.exit(1)


def unique_cves_from_file(file_path: Path) -> List[str]:
    """
    Get a list of all unique strings matching a CVE format in a given file

    :param file_path: file to parse
    :return: list of CVE numbers
    """
    try:
        exploit_file_contents = file_path.read_text(encoding="utf-8")
    except IOError as err:
        print("[!] skipping fileâ€¦", err)
        return []
    regex = r"CVE-\d{4}-\d{4,}"
    # quick way to keep it as a list, but make unique
    return list(set(re.compile(regex).findall(exploit_file_contents)))


def get_mapping(edb: Path) -> List[Dict]:
    """
    Create a mapping: EDBID -> CVEs

    :param edb: path to directory with cloned exploitdb repo
    :return: a mapping (list of dictionaries)
    """
    files_exploits = Path(edb, "files_exploits.csv")
    if not files_exploits.exists():
        sys.exit("[!] The file 'files_exploits.csv' not found in the specified directory.")
    m = []
    # loop through the file, grab the EDBID, parse the target file, and find CVEs in it.
    with open(files_exploits, mode="r", encoding="utf-8") as fe:
        for line in fe.readlines():
            # don't parse header (1st line)
            if not re.compile(r"id,file,description,date,author,type,platform,port").match(line):
                # file format is:
                # id,file,description,date,author,type,platform,port
                # but we just need first 2 columns
                edb_id, exploit_file, _ = line.split(",", maxsplit=2)
                cves = unique_cves_from_file(Path(edb, exploit_file))
                if len(cves) > 0:
                    # m.append({"id": edb_id, "cves": cves})
                    for cve in cves:
                        m.append({cve: edb_id})
    
    dict_data = {}
    for i in m:
        key, = i
        value, = i.values()
        dict_data[key] = value
    return dict_data


def get_mapping_path(edb: Path) -> List[Dict]:
    """
    Create a mapping: EDBID -> CVEs

    :param edb: path to directory with cloned exploitdb repo
    :return: a mapping (list of dictionaries)
    """
    files_exploits = Path(edb, "files_exploits.csv")
    if not files_exploits.exists():
        sys.exit("[!] The file 'files_exploits.csv' not found in the specified directory.")
    m = []
    # loop through the file, grab the EDBID, parse the target file, and find CVEs in it.
    with open(files_exploits, mode="r", encoding="utf-8") as fe:
        for line in fe.readlines():
            # don't parse header (1st line)
            if not re.compile(r"id,file,description,date,author,type,platform,port").match(line):
                # file format is:
                # id,file,description,date,author,type,platform,port
                # but we just need first 2 columns
                edb_id, exploit_file, _ = line.split(",", maxsplit=2)
                cves = unique_cves_from_file(Path(edb, exploit_file))
                if len(cves) > 0:
                    # m.append({"id": edb_id, "cves": cves})
                    for cve in cves:
                        m.append({cve: exploit_file})
    
    dict_data = {}
    for i in m:
        key, = i
        value, = i.values()
        dict_data[key] = value
    return dict_data

def cveMapEdbid():
    
    edb_path = Path("./exploitdb")
    if not is_repo(edb_path):
        clone_exploitdb(edb_path)
    
    mapping = get_mapping(edb_path)
    now = datetime.datetime.utcnow().isoformat(timespec='seconds')
    doc = {"timestamp": now, "mapping": mapping}
    with open("./edbid-to-cve-map.json", "w") as o:
        json.dump(doc, o)
    print(f"[*] Mapping written successfully into ./edbid-to-cve-map.json")


def cveMapPOC():
    edb_path = Path("./exploitdb")
    if not is_repo(edb_path):
        clone_exploitdb(edb_path)
    
    mapping = get_mapping_path(edb_path)
    now = datetime.datetime.utcnow().isoformat(timespec='seconds')
    doc = {"timestamp": now, "mapping": mapping}
    with open("./poc-to-cve-map.json", "w") as o:
        json.dump(doc, o)
    print(f"[*] Mapping written successfully into ./poc-to-cve-map.json")
    
if __name__ == '__main__':
    # dir .git  must exists, else clone project exploitdb
    cveMapEdbid()
    cveMapPOC()
    
    query_path = sys.argv[1]
    cve_list = open(query_path)
    # cve_list = open("docker_cve.txt")
    with open(pdir + "./edbid-to-cve-map.json") as data_file:
        cve_map = json.load(data_file)
    with open(pdir + "./poc-to-cve-map.json") as data_file_path:
        cve_map_path = json.load(data_file_path)

    for line in cve_list.readlines():
        if not line:
            break
        #print(line)  # do something
        cve = line.upper()
        mapping = cve_map['mapping']

        if cve not in mapping:
            print(cve + " no in db")
            continue

        mapping = cve_map_path['mapping']
        fpath = mapping[cve]
        # yield int(edb)
        print(cve + " : " + fpath)
        current_path = Path("./")
        from shutil import copyfile

        source = Path("./exploitdb", fpath)
        extName = os.path.splitext(fpath)[1]
        target =  Path("./out", cve+extName)
        if not Path("./out").exists():
            os.mkdir('./out')
        try:
            copyfile(source, target)
        except IOError as e:
            print("Unable to copy file. %s" % e)

            
    print(f'end')
    
